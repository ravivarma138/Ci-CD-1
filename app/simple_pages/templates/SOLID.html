<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    {% block head %}
        <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"/>
        <script src="{{ url_for('static', filename='js/scripts.js') }}"></script>

        <title>This is {{ name }} Website</title>
    {% endblock %}
</head>
<body>
<div class="container">
    <div class="center">
        <h1><strong>Calculator demonstrating SOLID</strong></h1>
        <p>@staticmethod<br>
            def add(tuple_list) <br>
            """this is a method"""<br>
            calculation=Addition.create(tuple_list);<br>
            return caculation.get_result()<br></p>

        <strong>This is the code from calculator project in which we could identify encapsulation and
            abstraction.</strong>
    </div>
</div>
<p>These principles establish practices that lend to developing software with considerations for maintaining and
    extending as the project grows. Adopting these practices can also contribute to avoiding code smells, refactoring
    code, and Agile or Adaptive software development.<br>

    SOLID stands for:<br>

    S - Single-responsiblity Principle<br>
    O - Open-closed Principle<br>
    L - Liskov Substitution Principle<br>
    I - Interface Segregation Principle<br>
    D - Dependency Inversion Principle<br>
    In this article, you will be introduced to each principle individually to understand how SOLID can help make you a
    better developer.<br>

    In the above piece of code the function executes only one job which means that the function follws a <strong>single
        responsibility principle</strong><br>
    The only responsible thing done by the function is to create a tuple list to perform addition and store it<br></p>

<div class="container">
    <div class="center">
        <h1><strong>Factory method in calculator</strong></h1>
        <p>@classmethod<br>
            def create(cls,tuple_list:tuple): <br>
            """factory method"""<br>
            return cls(tuple_list)<br></p>

        <strong>This is the code from calculator project in which we could actually describe about factory
            method</strong>
    </div>
</div>
<p>factory function is design pattern and its purpose is to return an instance of class<br>
    if you look at the first piece of code along with this code :<br>
    Basically we need an addition calculation where the create function returns the instance of addition calculation<br>
    whenever the static method executes it is going to invoke factory method which is create and a tuple is passed into
    it<br>
    factory function follows single responsibility principle and its primary task is to create an instance of the method
    or function.<br>


</p>


</body>
