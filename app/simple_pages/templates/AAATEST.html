<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    {% block head %}
        <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}"/>

        <title>{% block title %}{% endblock %}This is {{ name }} Website</title>
    {% endblock %}
</head>
<body>
<h1><strong>AAA TESTING TUTORIAL</strong></h1>
<div class="center">
    <p>The “Arrange-Act-Assert” (also AAA and 3A) pattern of testing was observed and named by Bill Wake in 2001. I
        first
        came across it in Kent Beck’s book “Test Driven Development: By Example” and I spoke about it at PyConUK
        2016.<br>

        The pattern focuses each test on a single action. The advantage of this focus is that it clearly separates
        the
        arrangement of the System Under Test (SUT) and the assertions that are made on it after the action.<br>

        On multiple projects I’ve worked on I’ve experienced organised and “clean” code in the main codebase, but
        disorganisation and inconsistency in the test suite. However when AAA is applied, I’ve found it helps by
        unifying
        and clarifying the structure of tests which helps make the test suite much more understandable and
        manageable<br>
    </p></div>
<p>Using AAA consistently makes it easier to find the Action in a test. It’s therefore always easy to see the object
    behaviour each test is focused on.</p><br>
<p><strong> How to structure a unit test: the Arrange-Act-Assert pattern</strong></p><br>
<p>This is the simple pattern in the structure of every unit test. The following is a Calculator class with a single
    method which calculates a sum of two numbers:</p><br>
<p>Public Class Calculator<br>
    {public double sum(double first, double second)<br>
    {return first + second;}<br>
    }<br>
</p>


<p>
<div class="container">
    <div class="center">
        <img src="https://freecontent.manning.com/wp-content/uploads/unit-test-design-part1-aaa_01.jpg"
             alt="AAA TESTING"
             width="500" height="600">

    </div>
    <p><strong> Implementing the AAA pattern</strong></p><br>
    <p>Unit Testing<br>
        Here’s a basic unit test for Python’s absolute value function:<br>

        def test_abs_for_a_negative_number():<br>

        # Arrange<br>
        negative = -5<br>

        # Act<br>
        answer = abs(negative)<br>

        # Assert<br>
        assert answer == 5<br>

        def test_abs_for_a_negative_number():<br>

        # Arrange<br>
        negative = -5<br>

        # Act
        answer = abs(negative)<br>

        # Assert<br>
        assert answer == 5<br>
        This test may seem trivial, but we can use it to illustrate our pattern. I like to write comments denoting each
        phase of the test case as well.<br>

        The Arrange step creates a variable named “negative” for testing.<br>
        The Act step calls the “abs” function using the “negative” variable and stores the returned value in a variable
        named “answer.”<br>
        The Assert step verifies that “answer” is a positive value.</p> <br>


</div>
<p>Arrange-Act-Assert is powerful because it is simple. It forces tests to focus on independent, individual
    behaviors.<br>It separates setup actions from the main actions.<br> It requires test to make verifications and not
    merely run through motions.<br> Notice how the pattern is not Arrange-Act-Assert-Act-Assert – subsequent actions and
    assertions belong in separate tests! Arrange-Act-Assert is a great pattern to follow for writing good functional
    tests.

</p>
</body>
</html>